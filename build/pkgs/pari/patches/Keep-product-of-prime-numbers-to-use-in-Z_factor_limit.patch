From ea6992e38d651643982fd88777d5d5a186b0f54e Mon Sep 17 00:00:00 2001
From: Bill Allombert <Bill.Allombert@math.u-bordeaux.fr>
Date: Wed, 16 Nov 2022 13:33:21 +0100
Subject: [PATCH] Keep product of prime numbers to use in Z_factor_limit

---
 src/basemath/ifactor1.c | 67 ++++++++++++++++++++++++++++++++---------
 src/headers/paridecl.h  |  2 ++
 src/language/forprime.c | 26 +++++++++++++++-
 3 files changed, 80 insertions(+), 15 deletions(-)

diff --git a/src/basemath/ifactor1.c b/src/basemath/ifactor1.c
index 4478fc416..5dd04c966 100644
--- a/src/basemath/ifactor1.c
+++ b/src/basemath/ifactor1.c
@@ -3652,29 +3652,68 @@ ifactor_sign(GEN n, ulong all, long hint, long sn, GEN *pU)
       av = avma; affii(shifti(n,-i), n); set_avma(av);
     }
     if (is_pm1(n)) return aux_end(M,n,nb);
-    /* trial division */
     maxp = maxprime();
-    av = avma; u_forprime_init(&T, 3, minss(lim, maxp)); av2 = avma;
-    /* first pass: known to fit in private prime table */
-    while ((p = u_forprime_next_fast(&T)))
+    if (lim >= maxprimelim()>>2)
     {
-      pari_sp av3 = avma;
-      int stop;
-      long k = Z_lvalrem_stop(&n, p, &stop);
-      if (k)
+      GEN nr, NR;
+      /* fast trial division */
+      av = avma;
+      NR = nr = gcdii(prodprimes(),n);
+      u_forprime_init(&T, 3, minss(lim, maxp)); av2 = avma;
+      /* first pass: known to fit in private prime table */
+      while ((p = u_forprime_next_fast(&T)))
       {
-        affii(n, N); n = N; set_avma(av3);
-        STOREu(&nb, p, k);
+        pari_sp av3 = avma;
+        int stop;
+        long k;
+        if (!dvdiu(nr, p)) continue;
+        nr = diviuexact(nr, p);
+        affii(nr, NR); nr = NR; set_avma(av3);
+        k = Z_lvalrem_stop(&n, p, &stop);
+        if (k)
+        {
+          affii(n, N); n = N; set_avma(av3);
+          STOREu(&nb, p, k);
+        }
+        if (is_pm1(n))
+        {
+          stackdummy(av, av2);
+          return aux_end(M,n,nb);
+        }
+        if (is_pm1(nr)) break;
       }
-      if (p == 16381 && bit_accuracy(lgefint(n)) < 2048)
-      { stop = ifac_isprime(n); nb0 = nb; }
-      if (stop)
+      if (ifac_isprime(n))
       {
-        if (!is_pm1(n)) STOREi(&nb, n, 1);
+        STOREi(&nb, n, 1);
         stackdummy(av, av2);
         return aux_end(M,n,nb);
       }
     }
+    else
+    {
+      /* trial division */
+      av = avma; u_forprime_init(&T, 3, minss(lim, maxp)); av2 = avma;
+      /* first pass: known to fit in private prime table */
+      while ((p = u_forprime_next_fast(&T)))
+      {
+        pari_sp av3 = avma;
+        int stop;
+        long k = Z_lvalrem_stop(&n, p, &stop);
+        if (k)
+        {
+          affii(n, N); n = N; set_avma(av3);
+          STOREu(&nb, p, k);
+        }
+        if (p == 16381 && bit_accuracy(lgefint(n)) < 2048)
+        { stop = ifac_isprime(n); nb0 = nb; }
+        if (stop)
+        {
+          if (!is_pm1(n)) STOREi(&nb, n, 1);
+          stackdummy(av, av2);
+          return aux_end(M,n,nb);
+        }
+      }
+    }
     stackdummy(av, av2);
     if (lim > maxp)
     { /* second pass, usually empty: outside private prime table */
diff --git a/src/headers/paridecl.h b/src/headers/paridecl.h
index be375c67d..1d5041e7f 100644
--- a/src/headers/paridecl.h
+++ b/src/headers/paridecl.h
@@ -3565,7 +3565,9 @@ ulong   init_primepointer_lt(ulong a, byteptr *pd);
 ulong   maxprime(void);
 ulong   maxprimeN(void);
 void    maxprime_check(ulong c);
+ulong   maxprimelim(void);
 void    pari_init_primes(ulong maxprime);
+GEN     prodprimes(void);
 ulong   u_forprime_next(forprime_t *T);
 int     u_forprime_init(forprime_t *T, ulong a, ulong b);
 void    u_forprime_restrict(forprime_t *T, ulong c);
diff --git a/src/language/forprime.c b/src/language/forprime.c
index 22be44726..1059900df 100644
--- a/src/language/forprime.c
+++ b/src/language/forprime.c
@@ -22,7 +22,9 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
 /**********************************************************************/
 
 static ulong _maxprime = 0;
+static ulong _maxprimelim = 0;
 static ulong diffptrlen;
+static GEN _prodprimes;
 
 /* Building/Rebuilding the diffptr table. The actual work is done by the
  * following two subroutines;  the user entry point is the function
@@ -352,6 +354,18 @@ sieve_chunk(byteptr known_primes, ulong s, byteptr data, ulong n)
   }
 }
 
+static void
+set_prodprimes(void)
+{
+  pari_sp av = avma;
+  GEN p = zv_prod_Z(primes_zv(diffptrlen-1));
+  long i, l = lgefint(p);
+  _prodprimes = (GEN) pari_malloc(l*sizeof(long));
+  for (i = 0; i < l; i++)
+    _prodprimes[i] = p[i];
+  set_avma(av);
+}
+
 /* assume maxnum <= 436273289 < 2^29 */
 static void
 initprimes0(ulong maxnum, long *lenp, ulong *lastp, byteptr p1)
@@ -426,7 +440,11 @@ initprimes0(ulong maxnum, long *lenp, ulong *lastp, byteptr p1)
 ulong
 maxprime(void) { return diffptr ? _maxprime : 0; }
 ulong
+maxprimelim(void) { return diffptr ? _maxprimelim : 0; }
+ulong
 maxprimeN(void) { return diffptr ? diffptrlen-1: 0; }
+GEN
+prodprimes(void) { return diffptr ? _prodprimes: NULL; }
 
 void
 maxprime_check(ulong c) { if (_maxprime < c) pari_err_MAXPRIME(c); }
@@ -445,6 +463,7 @@ initprimes(ulong maxnum, long *lenp, ulong *lastp)
     maxnum = 436273289;
   t = (byteptr)pari_malloc((size_t) (1.09 * maxnum/log((double)maxnum)) + 146);
   initprimes0(maxnum, lenp, lastp, t);
+  _maxprimelim = maxnum;
   return (byteptr)pari_realloc(t, *lenp);
 }
 
@@ -457,6 +476,7 @@ initprimetable(ulong maxnum)
   diffptrlen = minss(diffptrlen, len);
   _maxprime  = minss(_maxprime,last); /*Protect against ^C*/
   diffptr = p; diffptrlen = len; _maxprime = last;
+  set_prodprimes();
   if (old) free(old);
 }
 
@@ -770,7 +790,11 @@ pari_init_primes(ulong maxprime)
 void
 pari_close_primes(void)
 {
-  pari_free(diffptr);
+  if (diffptr)
+  {
+    pari_free(diffptr);
+    pari_free(_prodprimes);
+  }
   pari_free(pari_sieve_modular.sieve);
 }
 
-- 
2.30.2

